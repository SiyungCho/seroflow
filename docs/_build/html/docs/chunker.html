

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chunker &mdash; Seroflow 1.0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=1ed6394b"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Context" href="context.html" />
    <link rel="prev" title="Cache" href="cache.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Seroflow
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Getting Started with Seroflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="seroflow.html">Seroflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache.html">Cache</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chunker</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Chunker</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#seroflow.chunker.chunker.Chunker"><code class="docutils literal notranslate"><span class="pre">Chunker</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.chunker.Chunker.__init__"><code class="docutils literal notranslate"><span class="pre">Chunker.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.chunker.Chunker.calculate_chunks"><code class="docutils literal notranslate"><span class="pre">Chunker.calculate_chunks()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.chunker.Chunker.check_keep_executing"><code class="docutils literal notranslate"><span class="pre">Chunker.check_keep_executing()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.chunker.Chunker.dequeue"><code class="docutils literal notranslate"><span class="pre">Chunker.dequeue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.chunker.Chunker.enqueue"><code class="docutils literal notranslate"><span class="pre">Chunker.enqueue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.chunker.Chunker.reload"><code class="docutils literal notranslate"><span class="pre">Chunker.reload()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.chunker.Chunker.save"><code class="docutils literal notranslate"><span class="pre">Chunker.save()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#directchunker">DirectChunker</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#seroflow.chunker.direct_chunker.DirectChunker"><code class="docutils literal notranslate"><span class="pre">DirectChunker</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.direct_chunker.DirectChunker.__init__"><code class="docutils literal notranslate"><span class="pre">DirectChunker.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.direct_chunker.DirectChunker.calculate_chunks"><code class="docutils literal notranslate"><span class="pre">DirectChunker.calculate_chunks()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-example">Initialization Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#directchunker-methodology">DirectChunker Methodology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#key-behaviors">Key behaviors:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#directchunker-methodology-example">DirectChunker Methodology Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#distributedchunker">DistributedChunker</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#seroflow.chunker.distributed_chunker.DistributedChunker"><code class="docutils literal notranslate"><span class="pre">DistributedChunker</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.distributed_chunker.DistributedChunker.__init__"><code class="docutils literal notranslate"><span class="pre">DistributedChunker.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#seroflow.chunker.distributed_chunker.DistributedChunker.calculate_chunks"><code class="docutils literal notranslate"><span class="pre">DistributedChunker.calculate_chunks()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id3">Initialization Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributedchunker-methodology">DistributedChunker Methodology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Key behaviors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#distributedchunker-methodology-example">DistributedChunker Methodology Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="context.html">Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="engine.html">Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="extract.html">Extractors</a></li>
<li class="toctree-l1"><a class="reference internal" href="load.html">Loaders</a></li>
<li class="toctree-l1"><a class="reference internal" href="log.html">Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="step.html">Step</a></li>
<li class="toctree-l1"><a class="reference internal" href="transform.html">Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="wrappers.html">Wrappers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Seroflow</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Chunker</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/docs/chunker.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="chunker">
<span id="id1"></span><h1>Chunker<a class="headerlink" href="#chunker" title="Link to this heading"></a></h1>
<p>The modules documented here define the interface and concrete implementation for <code class="docutils literal notranslate"><span class="pre">Seroflow</span></code> <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> partitioning (chunking).
They provide a common interface to calculating chunk coordinates, managing a queue of chunking coordinates, and saving/restoring the chunker’s state.
This ensures consistent chunker behavior across different chunking strategies.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Link to this heading"></a></h2>
<p>This documentation covers three modules:</p>
<ul class="simple">
<li><p><strong>chunker</strong>: Defines the <code class="docutils literal notranslate"><span class="pre">Chunker</span></code> abstract class, which specifies the interface for creating custom chunkers.</p></li>
<li><p><strong>direct_chunker</strong>: A concrete subclass of <code class="docutils literal notranslate"><span class="pre">Chunker</span></code> that calculates chunk coordinates in a round-robin fashion.</p></li>
</ul>
<p>It computes start and stop indices based on each <code class="docutils literal notranslate"><span class="pre">Step's</span></code> <code class="docutils literal notranslate"><span class="pre">chunk_size</span></code> and total number of rows, enqueuing tuples of <code class="docutils literal notranslate"><span class="pre">(start_index,</span> <span class="pre">nrows)</span></code> for use with <code class="docutils literal notranslate"><span class="pre">Extractor</span></code> Objects.</p>
<ul class="simple">
<li><p><strong>distributed_chunker</strong> : A concrete subclass of <code class="docutils literal notranslate"><span class="pre">Chunker</span></code> that calculates chunk coordinates using a distributed strategy.</p></li>
</ul>
<p>It computes the total number of chunks by combining the number of chunks available for each step and then evenly distributes rows among those chunks.
This ensures a balanced allocation of rows across all chunks for efficient parallel or segmented processing.</p>
</section>
<section id="id2">
<h2>Chunker<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Chunker</span></code> is an abstract base class (inheriting from <code class="docutils literal notranslate"><span class="pre">ABC</span></code>) for implementing chunking.
Derived classes must implement all the abstract methods to handle chunking operations.
This design enforces a standardized interface and behavior across different chunking strategies.</p>
<dl class="py class">
<dt class="sig sig-object py" id="seroflow.chunker.chunker.Chunker">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">seroflow.chunker.chunker.</span></span><span class="sig-name descname"><span class="pre">Chunker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.chunker.Chunker" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>The Chunker class is used for dividing a large dataset into smaller chunks for processing.
It examines the Pipeline’s indexes for steps that have a defined ‘chunk_size’; if applicable,
calculates the coordinates for each chunk.
It also manages a coordinate queue for chunk processing and provides methods for saving
and reloading the state of the chunker.
The class validates that any loader steps used in chunking are configured to append data.</p>
<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.chunker.Chunker.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.chunker.Chunker.__init__" title="Link to this definition"></a></dt>
<dd><p>Chunker Class Constructor method</p>
<p>Iterates through the provided step index to identify steps that support chunking.
For each step that has a ‘chunk_size’ attribute and is an extractor,
it initializes the chunk coordinates as a tuple containing:</p>
<blockquote>
<div><ul class="simple">
<li><p>The chunk size.</p></li>
<li><p>A starting index (initially 0).</p></li>
<li><p>The maximum row count as provided by step.get_max_row_count().</p></li>
<li><p>A flag (initially False) indicating completion status.</p></li>
</ul>
</div></blockquote>
<p>Also validates that any loader step (identified via is_loader) has its ‘exists’
attribute set to ‘append’, as required when using chunking.
Finally, it initializes a queue for managing chunk coordinates, a state dictionary
for saving the chunker state, and invokes the calculate_chunks() method to populate
the coordinate queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>step_index</strong> (<em>OrderedDict</em>) – An ordered dictionary mapping step keys to step objects in the Pipeline.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.chunker.Chunker.calculate_chunks">
<em class="property"><span class="k"><span class="pre">abstractmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">calculate_chunks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.chunker.Chunker.calculate_chunks" title="Link to this definition"></a></dt>
<dd><p>Abstract method: calculate_chunks()
Calculates coordinate values for the chunker.
Each chunk is defined by a start and stop index value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.chunker.Chunker.check_keep_executing">
<span class="sig-name descname"><span class="pre">check_keep_executing</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.chunker.Chunker.check_keep_executing" title="Link to this definition"></a></dt>
<dd><p>Public method: check_keep_executing()
Checks if the coordinate queue is empty</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True: if the queue is not empty
False: otherwise</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)">bool</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.chunker.Chunker.dequeue">
<span class="sig-name descname"><span class="pre">dequeue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.chunker.Chunker.dequeue" title="Link to this definition"></a></dt>
<dd><p>Public method: dequeue()
Removes a value from the coordinate queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A tuple containing start and stop index values corresponding to a chunk</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)">tuple</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.chunker.Chunker.enqueue">
<span class="sig-name descname"><span class="pre">enqueue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.chunker.Chunker.enqueue" title="Link to this definition"></a></dt>
<dd><p>Public method: enqueue()
Adds a value to the coordinate queue.
Chunking coordinates are tuples containing start and stop index values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>value</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)"><em>tuple</em></a>) – A tuple containing start and stop index values corresponding to a chunk</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.chunker.Chunker.reload">
<span class="sig-name descname"><span class="pre">reload</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.chunker.Chunker.reload" title="Link to this definition"></a></dt>
<dd><p>Public method: reload()
Reloads the chunker state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A tuple containing the parameter index and global context</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.13)">tuple</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.chunker.Chunker.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.chunker.Chunker.save" title="Link to this definition"></a></dt>
<dd><p>Public method: save()
Saves the chunker state</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>**kwargs</strong> – Keyword arguments to save, passed as key-value pairs
In this case, the parameter index and global context</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="directchunker">
<h2>DirectChunker<a class="headerlink" href="#directchunker" title="Link to this heading"></a></h2>
<p>A concrete implementation of the <code class="docutils literal notranslate"><span class="pre">Chunker</span></code> class that calculates chunk coordinates directly in a round-robin manner.</p>
<dl class="py class">
<dt class="sig sig-object py" id="seroflow.chunker.direct_chunker.DirectChunker">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">seroflow.chunker.direct_chunker.</span></span><span class="sig-name descname"><span class="pre">DirectChunker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.direct_chunker.DirectChunker" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#seroflow.chunker.chunker.Chunker" title="seroflow.chunker.chunker.Chunker"><code class="xref py py-class docutils literal notranslate"><span class="pre">Chunker</span></code></a></p>
<p>A concrete implementation of the Chunker class that calculates chunk coordinates directly.
It iterates through the steps that support chunking, computes the start and stop indices
based on the chunk size and total row count, and populates the coordinate queue with values.
If a step has finished processing all available rows, a (None, None) tuple is enqueued.</p>
<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.direct_chunker.DirectChunker.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.direct_chunker.DirectChunker.__init__" title="Link to this definition"></a></dt>
<dd><p>Direct Chunker Class Constructor method
Initializes the DirectChunker object by invoking the parent class constructor and
then invoking the calculate_chunks() method to populate the coordinate queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>step_index</strong> (<em>OrderedDict</em>) – An ordered dictionary mapping step keys to step objects in the Pipeline.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.direct_chunker.DirectChunker.calculate_chunks">
<span class="sig-name descname"><span class="pre">calculate_chunks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.direct_chunker.DirectChunker.calculate_chunks" title="Link to this definition"></a></dt>
<dd><p>Public method: calculate_chunks()
Calculates the chunk coordinates for each step in the chunk index.
The chunk coordinates are added to the coordinate queue.
Calculates by using the chunk size and the number of rows in the step.
If the chunk size is greater than the number of rows, the chunk size is set
to the number of rows.
A (None, None) tuple is added to the queue for each step that has finished calculating.</p>
<p>This version produces tuples of (start_index, nrows) for compatibility with
pandas read_csv’s skiprows and nrows.</p>
</dd></dl>

</dd></dl>

<section id="initialization-example">
<h3>Initialization Example<a class="headerlink" href="#initialization-example" title="Link to this heading"></a></h3>
<p>Below is a simple example that shows how to initialize a <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> object with an <code class="docutils literal notranslate"><span class="pre">LFUCache</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">seroflow</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">seroflow.chunker</span><span class="w"> </span><span class="kn">import</span> <span class="n">DirectChunker</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">chunker</span><span class="o">=</span><span class="n">DirectChunker</span><span class="p">)</span> <span class="c1"># Execute Pipeline with chunker</span>
</pre></div>
</div>
</section>
<section id="directchunker-methodology">
<h3>DirectChunker Methodology<a class="headerlink" href="#directchunker-methodology" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DirectChunker</span></code> partitions each extractor’s dataset into fixed‑size blocks in a simple round‑robin sequence.
It does not attempt to balance work across <code class="docutils literal notranslate"><span class="pre">Extractors</span></code> — instead, it iterates through each step in order, slicing off one chunk at a time until all rows for that step are consumed, then moving on to the next.</p>
</section>
<section id="key-behaviors">
<h3>Key behaviors:<a class="headerlink" href="#key-behaviors" title="Link to this heading"></a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><strong>Fixed‑size chunks</strong>:</dt><dd><p>Each chunk’s row count equals the extractor’s configured chunk_size, except the final chunk (which may be smaller if the total row count isn’t a multiple of chunk_size).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Round‑robin ordering</strong>:</dt><dd><p>Execution cycles through <code class="docutils literal notranslate"><span class="pre">Extractors</span></code> in <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> order. On each cycle, it emits one chunk coordinate <code class="docutils literal notranslate"><span class="pre">(start_index,</span> <span class="pre">nrows)</span></code> for each <code class="docutils literal notranslate"><span class="pre">Extractor</span></code> that still has rows remaining.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Skipping finished extractors</strong>:</dt><dd><p>Once an extractor has emitted all of its chunks, subsequent cycles enqueue <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code> for that step—telling <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> to skip it.</p>
</dd>
</dl>
</li>
<li><p><strong>Total iterations = sum of chunks across all ``Extractors``.</strong></p></li>
<li><p><strong>Logic</strong>:</p>
<ul>
<li><p>Retrieves a list of keys from <code class="docutils literal notranslate"><span class="pre">self.chunk_index</span></code> and iterates over them in a round-robin fashion.</p></li>
<li><p>For each key, retrieves the current chunk data: <code class="docutils literal notranslate"><span class="pre">(chunk_size,</span> <span class="pre">current_chunk,</span> <span class="pre">num_rows,</span> <span class="pre">finished_calculating)</span></code>.</p></li>
<li><p>If a step has finished processing, enqueues <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code>.</p></li>
<li><p>Otherwise, calculates:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">start_idx</span></code> as <code class="docutils literal notranslate"><span class="pre">current_chunk</span> <span class="pre">*</span> <span class="pre">chunk_size</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stop_idx</span></code> as the minimum of <code class="docutils literal notranslate"><span class="pre">start_idx</span> <span class="pre">+</span> <span class="pre">chunk_size</span></code> and <code class="docutils literal notranslate"><span class="pre">num_rows</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nrows</span></code> as <code class="docutils literal notranslate"><span class="pre">stop_idx</span> <span class="pre">-</span> <span class="pre">start_idx</span></code>.</p></li>
<li><p>Updates the finished flag if <code class="docutils literal notranslate"><span class="pre">stop_idx</span></code> reaches <code class="docutils literal notranslate"><span class="pre">num_rows</span></code>.</p></li>
</ul>
</li>
<li><p>Enqueues the tuple <code class="docutils literal notranslate"><span class="pre">(start_idx,</span> <span class="pre">nrows)</span></code>.</p></li>
<li><p>Updates the chunk index with the new current chunk count and finished flag.</p></li>
<li><p>Pads the coordinate queue with <code class="docutils literal notranslate"><span class="pre">(None,</span> <span class="pre">None)</span></code> tuples so that the total number of enqueued values is a multiple of the number of keys.</p></li>
</ul>
</li>
</ul>
</section>
<section id="directchunker-methodology-example">
<h3>DirectChunker Methodology Example<a class="headerlink" href="#directchunker-methodology-example" title="Link to this heading"></a></h3>
<div style="background:rgba(0,0,0,0.1); border-left:4px solid #0366d6; padding:1em; border-radius:4px;">
<p>Imagine three extractors (A, B, C) with differing dataset sizes and chunk sizes:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Extractor</p></th>
<th class="head text-center"><p>Total Rows</p></th>
<th class="head text-center"><p>Chunk Size</p></th>
<th class="head text-center"><p># Chunks</p></th>
<th class="head text-left"><p>Coordinates</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><strong>X</strong></p></td>
<td class="text-center"><p>100</p></td>
<td class="text-center"><p>50</p></td>
<td class="text-center"><p>2</p></td>
<td class="text-left"><p>(0,16), (16,16)<br/>(32,16), (48,16)<br/>(64,16), (80,16)</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><strong>Y</strong></p></td>
<td class="text-center"><p>60</p></td>
<td class="text-center"><p>20</p></td>
<td class="text-center"><p>3</p></td>
<td class="text-left"><p>(0,10), (10,10)<br/>(20,10), (30,10)<br/>(40,10), (50,10)</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><strong>Z</strong></p></td>
<td class="text-center"><p>30</p></td>
<td class="text-center"><p>30</p></td>
<td class="text-center"><p>1</p></td>
<td class="text-left"><p>(0,5), (5,5)<br/>(10,5), (15,5)<br/>(20,5), (25,5)</p></td>
</tr>
</tbody>
</table>
<p>The total # of executions = #Chunks X * #Chunks Y * #Chunks Z = 2 × 3 × 1 = 6.</p>
<p>Now to calculate the chunk coordinates we distribute the total rows across all 6 executions.</p>
<p>Extractor X: 100/6 = 16 Remainder 4</p>
<p>Extractor Y: 60/6 = 10</p>
<p>Extractor Z: 30/6 = 5</p>
<p>Therefore, the <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> will execute 6 seperate times:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Execution</p></th>
<th class="head text-center"><p>X</p></th>
<th class="head text-center"><p>Y</p></th>
<th class="head text-center"><p>Z</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>1</p></td>
<td class="text-center"><p>(0,16)</p></td>
<td class="text-center"><p>(0,10)</p></td>
<td class="text-center"><p>(0,5)</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>2</p></td>
<td class="text-center"><p>(16,16)</p></td>
<td class="text-center"><p>(10,10)</p></td>
<td class="text-center"><p>(5,5)</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>3</p></td>
<td class="text-center"><p>(32,16)</p></td>
<td class="text-center"><p>(20,10)</p></td>
<td class="text-center"><p>(10,5)</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>4</p></td>
<td class="text-center"><p>(48,16)</p></td>
<td class="text-center"><p>(30,10)</p></td>
<td class="text-center"><p>(15,5)</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>5</p></td>
<td class="text-center"><p>(64,16)</p></td>
<td class="text-center"><p>(40,10)</p></td>
<td class="text-center"><p>(20,5)</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>6</p></td>
<td class="text-center"><p>(80,16)</p></td>
<td class="text-center"><p>(50,10)</p></td>
<td class="text-center"><p>(25,5)</p></td>
</tr>
</tbody>
</table>
<p>The last execution will include the final chunk as well as any remaining rows of data.</p>
</div></section>
</section>
<section id="distributedchunker">
<h2>DistributedChunker<a class="headerlink" href="#distributedchunker" title="Link to this heading"></a></h2>
<p>A concrete implementation of the <code class="docutils literal notranslate"><span class="pre">Chunker</span></code> class that calculates chunk coordinates using a distributed strategy.
Instead of processing chunks in a round-robin manner, <code class="docutils literal notranslate"><span class="pre">DistributedChunker</span></code> computes the total number of chunks based on the individual chunk sizes of the steps and then evenly distributes rows among those chunks.
This approach ensures a balanced allocation of rows for efficient parallel or segmented processing.</p>
<dl class="py class">
<dt class="sig sig-object py" id="seroflow.chunker.distributed_chunker.DistributedChunker">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">seroflow.chunker.distributed_chunker.</span></span><span class="sig-name descname"><span class="pre">DistributedChunker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.distributed_chunker.DistributedChunker" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#seroflow.chunker.chunker.Chunker" title="seroflow.chunker.chunker.Chunker"><code class="xref py py-class docutils literal notranslate"><span class="pre">Chunker</span></code></a></p>
<p>A concrete implementation of the Chunker class that calculates chunk coordinates using a
distributed strategy. Instead of processing chunks in a round-robin manner, this chunker
computes the total number of chunks based on the individual chunk sizes of the steps and
then calculates the start and end indices for each chunk, ensuring an even distribution.</p>
<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.distributed_chunker.DistributedChunker.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">step_index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.distributed_chunker.DistributedChunker.__init__" title="Link to this definition"></a></dt>
<dd><p>Distributed Chunker Class Constructor
Initializes the DistributedChunker object by invoking the parent class constructor
and then invoking the calculate_chunks() method to populate the coordinate queue.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>step_index</strong> (<em>OrderedDict</em>) – An ordered dictionary mapping step keys to step objects in the Pipeline.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="seroflow.chunker.distributed_chunker.DistributedChunker.calculate_chunks">
<span class="sig-name descname"><span class="pre">calculate_chunks</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#seroflow.chunker.distributed_chunker.DistributedChunker.calculate_chunks" title="Link to this definition"></a></dt>
<dd><p>Public method: calculate_chunks()
Calculates the chunk coordinates for each step in the chunk index.
The chunk coordinates are added to the coordinate queue.
Recursive Chunker calculates the chunk coordinates by first calculating the total
number of chunks and then iterating through each chunk to calculate the start index
and number of rows for each chunk.
By using the total number of chunks, the method calculates the base number of rows
per chunk and the remainder. This way, the method can distribute the remainder
among the chunks, resulting in an even distribution of rows.</p>
<p>This version produces tuples of (start_index, nrows) for
compatibility with pandas read_csv.</p>
</dd></dl>

</dd></dl>

<section id="id3">
<h3>Initialization Example<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>Below is a simple example that shows how to initialize a <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> object with an <code class="docutils literal notranslate"><span class="pre">LFUCache</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">seroflow</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">seroflow.chunker</span><span class="w"> </span><span class="kn">import</span> <span class="n">DistributedChunker</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">()</span>
<span class="n">pipeline</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">chunker</span><span class="o">=</span><span class="n">DistributedChunker</span><span class="p">)</span> <span class="c1"># Execute Pipeline with chunker</span>
</pre></div>
</div>
</section>
<section id="distributedchunker-methodology">
<h3>DistributedChunker Methodology<a class="headerlink" href="#distributedchunker-methodology" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DistributedChunker</span></code> evenly spreads rows across a unified set of execution chunks so that every run contains work for every extractor (unless the extractor has fewer total rows than the number of chunks).
It computes the total number of chunks as the product of each extractor’s chunk‑count, then divides each extractor’s rows evenly across those chunks.</p>
</section>
<section id="id4">
<h3>Key behaviors<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<ul>
<li><dl class="simple">
<dt><strong>Balanced distribution</strong>:</dt><dd><p>Rows for each extractor are split into nearly equal‑sized pieces, minimizing empty (zero‑row) runs.</p>
</dd>
</dl>
</li>
<li><p><strong>Total iterations = ∏ (ceil(total_rows_i / chunk_size_i)) for all extractors.</strong></p></li>
<li><dl class="simple">
<dt><strong>Remainder handling</strong>:</dt><dd><p>If rows don’t divide evenly, earlier chunks receive one extra row until the remainder is exhausted.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>Zero‑row chunks</strong>:</dt><dd><p>If an extractor’s total rows are fewer than the total number of chunks, some chunks will contain (None, None) for that extractor.</p>
</dd>
</dl>
</li>
<li><p><strong>Logic</strong>:
- <strong>Step 1:</strong> Determine the number of chunks per step.</p>
<blockquote>
<div><ul class="simple">
<li><p>For each key in <code class="docutils literal notranslate"><span class="pre">self.chunk_index</span></code>, retrieve <code class="docutils literal notranslate"><span class="pre">(chunk_size,</span> <span class="pre">_,</span> <span class="pre">num_rows,</span> <span class="pre">_)</span></code>.</p></li>
<li><p>Calculate the number of chunks for that step as <code class="docutils literal notranslate"><span class="pre">ceil(num_rows</span> <span class="pre">/</span> <span class="pre">chunk_size)</span></code> and store it in a dictionary <code class="docutils literal notranslate"><span class="pre">chunks_per_key</span></code>.</p></li>
</ul>
</div></blockquote>
<ul>
<li><p><strong>Step 2:</strong> Compute the total number of chunks.
- Multiply the number of chunks for each step together to get <code class="docutils literal notranslate"><span class="pre">total_chunks</span></code>.</p></li>
<li><p><strong>Step 3:</strong> For each chunk (from 0 to <code class="docutils literal notranslate"><span class="pre">total_chunks</span> <span class="pre">-</span> <span class="pre">1</span></code>):
- For each key in the chunk index:</p>
<blockquote>
<div><ul class="simple">
<li><p>Retrieve <code class="docutils literal notranslate"><span class="pre">num_rows</span></code> for the step.</p></li>
<li><p>Calculate the base number of rows per chunk as <code class="docutils literal notranslate"><span class="pre">num_rows</span> <span class="pre">//</span> <span class="pre">total_chunks</span></code> and the remainder as <code class="docutils literal notranslate"><span class="pre">num_rows</span> <span class="pre">%</span> <span class="pre">total_chunks</span></code>.</p></li>
<li><p>Determine <code class="docutils literal notranslate"><span class="pre">start_idx</span></code> as <code class="docutils literal notranslate"><span class="pre">chunk</span> <span class="pre">*</span> <span class="pre">base</span> <span class="pre">+</span> <span class="pre">min(chunk,</span> <span class="pre">remainder)</span></code>.</p></li>
<li><p>Compute <code class="docutils literal notranslate"><span class="pre">end_idx</span></code> as <code class="docutils literal notranslate"><span class="pre">start_idx</span> <span class="pre">+</span> <span class="pre">base</span> <span class="pre">+</span> <span class="pre">(1</span> <span class="pre">if</span> <span class="pre">chunk</span> <span class="pre">&lt;</span> <span class="pre">remainder</span> <span class="pre">else</span> <span class="pre">0)</span></code>.</p></li>
<li><p>Calculate <code class="docutils literal notranslate"><span class="pre">nrows</span></code> as <code class="docutils literal notranslate"><span class="pre">end_idx</span> <span class="pre">-</span> <span class="pre">start_idx</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">nrows</span></code> is 0, break out of the loop for that key.</p></li>
<li><p>Enqueue the tuple <code class="docutils literal notranslate"><span class="pre">(start_idx,</span> <span class="pre">nrows)</span></code> in the coordinate queue.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>This produces tuples of <code class="docutils literal notranslate"><span class="pre">(start_index,</span> <span class="pre">nrows)</span></code> that are compatible with functions such as pandas <code class="docutils literal notranslate"><span class="pre">read_csv</span></code>.</p></li>
</ul>
</li>
</ul>
</section>
<section id="distributedchunker-methodology-example">
<h3>DistributedChunker Methodology Example<a class="headerlink" href="#distributedchunker-methodology-example" title="Link to this heading"></a></h3>
<div style="background:rgba(0,0,0,0.1); border-left:4px solid #0366d6; padding:1em; border-radius:4px;">
<p>Imagine three extractors (A, B, C) with differing dataset sizes and chunk sizes:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Extractor</p></th>
<th class="head text-center"><p>Total Rows</p></th>
<th class="head text-center"><p>Chunk Size</p></th>
<th class="head text-center"><p># Chunks</p></th>
<th class="head text-left"><p>Coordinates</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><strong>X</strong></p></td>
<td class="text-center"><p>100</p></td>
<td class="text-center"><p>50</p></td>
<td class="text-center"><p>2</p></td>
<td class="text-left"><p>(0,16), (16,16)<br/>(32,16), (48,16)<br/>(64,16), (80,16)</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><strong>Y</strong></p></td>
<td class="text-center"><p>60</p></td>
<td class="text-center"><p>20</p></td>
<td class="text-center"><p>3</p></td>
<td class="text-left"><p>(0,10), (10,10)<br/>(20,10), (30,10)<br/>(40,10), (50,10)</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><strong>Z</strong></p></td>
<td class="text-center"><p>30</p></td>
<td class="text-center"><p>30</p></td>
<td class="text-center"><p>1</p></td>
<td class="text-left"><p>(0,5), (5,5)<br/>(10,5), (15,5)<br/>(20,5), (25,5)</p></td>
</tr>
</tbody>
</table>
<p>The total # of executions = #Chunks X * #Chunks Y * #Chunks Z = 2 × 3 × 1 = 6.</p>
<p>Now to calculate the chunk coordinates we distribute the total rows across all 6 executions.</p>
<p>Extractor X: 100/6 = 16 Remainder 4</p>
<p>Extractor Y: 60/6 = 10</p>
<p>Extractor Z: 30/6 = 5</p>
<p>Therefore, the <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> will execute 6 seperate times:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Execution</p></th>
<th class="head text-center"><p>X</p></th>
<th class="head text-center"><p>Y</p></th>
<th class="head text-center"><p>Z</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>1</p></td>
<td class="text-center"><p>(0,16)</p></td>
<td class="text-center"><p>(0,10)</p></td>
<td class="text-center"><p>(0,5)</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>2</p></td>
<td class="text-center"><p>(16,16)</p></td>
<td class="text-center"><p>(10,10)</p></td>
<td class="text-center"><p>(5,5)</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>3</p></td>
<td class="text-center"><p>(32,16)</p></td>
<td class="text-center"><p>(20,10)</p></td>
<td class="text-center"><p>(10,5)</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>4</p></td>
<td class="text-center"><p>(48,16)</p></td>
<td class="text-center"><p>(30,10)</p></td>
<td class="text-center"><p>(15,5)</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>5</p></td>
<td class="text-center"><p>(64,16)</p></td>
<td class="text-center"><p>(40,10)</p></td>
<td class="text-center"><p>(20,5)</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>6</p></td>
<td class="text-center"><p>(80,16)</p></td>
<td class="text-center"><p>(50,10)</p></td>
<td class="text-center"><p>(25,5)</p></td>
</tr>
</tbody>
</table>
<p>The last execution will include the final chunk as well as any remaining rows of data.</p>
</div></section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="cache.html" class="btn btn-neutral float-left" title="Cache" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="context.html" class="btn btn-neutral float-right" title="Context" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Frank Siyung Cho.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>